{"ast":null,"code":"import { Interval } from '../interval';\nimport rmath from '../round';\nimport * as utils from './utils';\nimport constants from '../constants';\n/**\n * Division between intervals when `y` doesn't contain zero\n * @param {Interval} x\n * @param {Interval} y\n * @returns {Interval}\n */\nexport function nonZero(x, y) {\n  const xl = x.lo;\n  const xh = x.hi;\n  const yl = y.lo;\n  const yh = y.hi;\n  const out = new Interval();\n  if (xh < 0) {\n    if (yh < 0) {\n      out.lo = rmath.divLo(xh, yl);\n      out.hi = rmath.divHi(xl, yh);\n    } else {\n      out.lo = rmath.divLo(xl, yl);\n      out.hi = rmath.divHi(xh, yh);\n    }\n  } else if (xl < 0) {\n    if (yh < 0) {\n      out.lo = rmath.divLo(xh, yh);\n      out.hi = rmath.divHi(xl, yh);\n    } else {\n      out.lo = rmath.divLo(xl, yl);\n      out.hi = rmath.divHi(xh, yl);\n    }\n  } else {\n    if (yh < 0) {\n      out.lo = rmath.divLo(xh, yh);\n      out.hi = rmath.divHi(xl, yl);\n    } else {\n      out.lo = rmath.divLo(xl, yh);\n      out.hi = rmath.divHi(xh, yl);\n    }\n  }\n  return out;\n}\n/**\n * Division between an interval and a positive constant\n * @param {Interval} x\n * @param {number} v\n * @returns {Interval}\n */\nexport function positive(x, v) {\n  if (x.lo === 0 && x.hi === 0) {\n    return x;\n  }\n  if (utils.zeroIn(x)) {\n    // mixed considering zero in both ends\n    return constants.WHOLE;\n  }\n  if (x.hi < 0) {\n    // negative / v\n    return new Interval(Number.NEGATIVE_INFINITY, rmath.divHi(x.hi, v));\n  } else {\n    // positive / v\n    return new Interval(rmath.divLo(x.lo, v), Number.POSITIVE_INFINITY);\n  }\n}\n/**\n * Division between an interval and a negative constant\n * @param {Interval} x\n * @param {number} v\n * @returns {Interval}\n */\nexport function negative(x, v) {\n  if (x.lo === 0 && x.hi === 0) {\n    return x;\n  }\n  if (utils.zeroIn(x)) {\n    // mixed considering zero in both ends\n    return constants.WHOLE;\n  }\n  if (x.hi < 0) {\n    // negative / v\n    return new Interval(rmath.divLo(x.hi, v), Number.POSITIVE_INFINITY);\n  } else {\n    // positive / v\n    return new Interval(Number.NEGATIVE_INFINITY, rmath.divHi(x.lo, v));\n  }\n}\n/**\n * Division between an interval and zero\n * @param {Interval} x\n * @returns {Interval}\n */\nexport function zero(x) {\n  if (x.lo === 0 && x.hi === 0) {\n    return x;\n  }\n  return constants.WHOLE;\n}","map":{"version":3,"names":["Interval","rmath","utils","constants","nonZero","x","y","xl","lo","xh","hi","yl","yh","out","divLo","divHi","positive","v","zeroIn","WHOLE","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","negative","zero"],"sources":["../../src/operations/division.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}